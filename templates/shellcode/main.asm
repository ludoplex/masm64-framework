;-----------------------------------------------------------------------------
; {{PROJECT_NAME}} - Position-Independent Shellcode
;-----------------------------------------------------------------------------
; Template: MASM64 Position-Independent Code (Shellcode)
; Generated by MASM64 Framework
;
; This template provides a foundation for writing position-independent
; x64 shellcode for security research and exploit development.
;
; WARNING: Use responsibly and only in authorized security testing.
;-----------------------------------------------------------------------------

OPTION CASEMAP:NONE

;-----------------------------------------------------------------------------
; PEB/TEB Offsets (x64)
;-----------------------------------------------------------------------------
; These are used to locate kernel32.dll without hardcoded addresses
;-----------------------------------------------------------------------------
TEB_PEB_OFFSET          EQU 60h         ; gs:[60h] = PEB pointer
PEB_LDR_OFFSET          EQU 18h         ; PEB->Ldr
LDR_INLOAD_OFFSET       EQU 20h         ; Ldr->InLoadOrderModuleList
LDR_DLLBASE_OFFSET      EQU 30h         ; Entry->DllBase
LDR_FULLNAME_OFFSET     EQU 48h         ; Entry->FullDllName

;-----------------------------------------------------------------------------
; Hash constants for API resolution
;-----------------------------------------------------------------------------
; Hashes for common functions (djb2 algorithm)
;-----------------------------------------------------------------------------
HASH_KERNEL32           EQU 06A4ABC5Bh
HASH_LOADLIBRARYA       EQU 0EC0E4E8Eh
HASH_GETPROCADDRESS     EQU 07C0DFCAA0h
HASH_EXITPROCESS        EQU 073E2D87Eh

;-----------------------------------------------------------------------------
; Code Section - Position Independent
;-----------------------------------------------------------------------------
.CODE

;-----------------------------------------------------------------------------
; Entry Point - Must be first
;-----------------------------------------------------------------------------
ShellcodeEntry PROC
    ; Save registers we'll use
    push rbx
    push rdi
    push rsi
    push r12
    push r13
    push r14
    push r15
    sub rsp, 88                         ; Shadow space + alignment
    
    ; Get kernel32 base address
    call FindKernel32
    test rax, rax
    jz exit_shellcode
    mov r12, rax                        ; r12 = kernel32 base
    
    ; Find GetProcAddress
    mov rcx, r12                        ; DllBase
    mov edx, HASH_GETPROCADDRESS
    call FindExportByHash
    test rax, rax
    jz exit_shellcode
    mov r13, rax                        ; r13 = GetProcAddress
    
    ; Find LoadLibraryA
    mov rcx, r12
    mov edx, HASH_LOADLIBRARYA
    call FindExportByHash
    test rax, rax
    jz exit_shellcode
    mov r14, rax                        ; r14 = LoadLibraryA
    
    ; Find ExitProcess
    mov rcx, r12
    mov edx, HASH_EXITPROCESS
    call FindExportByHash
    test rax, rax
    jz exit_shellcode
    mov r15, rax                        ; r15 = ExitProcess
    
    ;-------------------------------------------------------------------------
    ; PAYLOAD GOES HERE
    ;-------------------------------------------------------------------------
    ; At this point:
    ;   r12 = kernel32.dll base
    ;   r13 = GetProcAddress
    ;   r14 = LoadLibraryA
    ;   r15 = ExitProcess
    ;
    ; Example: Call ExitProcess(0)
    xor ecx, ecx
    call r15
    ;-------------------------------------------------------------------------
    
exit_shellcode:
    add rsp, 88
    pop r15
    pop r14
    pop r13
    pop r12
    pop rsi
    pop rdi
    pop rbx
    ret
ShellcodeEntry ENDP

;-----------------------------------------------------------------------------
; FindKernel32 - Locate kernel32.dll via PEB
;-----------------------------------------------------------------------------
; Returns: RAX = kernel32.dll base address, or 0 on failure
;-----------------------------------------------------------------------------
FindKernel32 PROC
    push rbx
    push rdi
    sub rsp, 40
    
    ; Get PEB from TEB
    mov rax, gs:[TEB_PEB_OFFSET]        ; RAX = PEB
    test rax, rax
    jz not_found
    
    ; Get PEB_LDR_DATA
    mov rax, [rax + PEB_LDR_OFFSET]     ; RAX = Ldr
    test rax, rax
    jz not_found
    
    ; Get first entry in InLoadOrderModuleList
    mov rdi, [rax + LDR_INLOAD_OFFSET]  ; First entry (usually ntdll)
    mov rbx, rdi                        ; Save list head
    
walk_list:
    ; Check if we've looped back
    mov rax, [rdi]                      ; Next entry
    cmp rax, rbx
    je not_found
    
    ; Move to next entry
    mov rdi, rax
    
    ; Get DLL base
    mov rax, [rdi + LDR_DLLBASE_OFFSET]
    test rax, rax
    jz walk_list
    
    ; Check for kernel32.dll by examining module name
    ; The third module is typically kernel32.dll on Windows 10+
    ; More robust: hash the name and compare
    
    ; For simplicity, get the name and check for 'k' or 'K' at start
    mov rcx, [rdi + LDR_FULLNAME_OFFSET + 8]  ; UNICODE_STRING.Buffer
    test rcx, rcx
    jz walk_list
    
    ; Find last backslash
    xor rdx, rdx
find_name:
    movzx eax, WORD PTR [rcx + rdx*2]
    test ax, ax
    jz check_name
    cmp ax, '\'
    jne next_char
    lea r8, [rcx + rdx*2 + 2]           ; Save position after backslash
next_char:
    inc rdx
    jmp find_name
    
check_name:
    test r8, r8
    jz walk_list
    
    ; Check for "KERNEL32" or "kernel32"
    movzx eax, WORD PTR [r8]
    or al, 20h                          ; To lowercase
    cmp al, 'k'
    jne walk_list
    
    movzx eax, WORD PTR [r8 + 2]
    or al, 20h
    cmp al, 'e'
    jne walk_list
    
    ; Found kernel32
    mov rax, [rdi + LDR_DLLBASE_OFFSET]
    jmp done
    
not_found:
    xor eax, eax
    
done:
    add rsp, 40
    pop rdi
    pop rbx
    ret
FindKernel32 ENDP

;-----------------------------------------------------------------------------
; FindExportByHash - Find export by hash
;-----------------------------------------------------------------------------
; Parameters: RCX = DllBase, EDX = Hash
; Returns: RAX = Function address, or 0
;-----------------------------------------------------------------------------
FindExportByHash PROC
    push rbx
    push rdi
    push rsi
    push r12
    push r13
    sub rsp, 56
    
    mov r12, rcx                        ; DllBase
    mov r13d, edx                       ; Hash
    
    ; Parse PE headers
    mov eax, [r12 + 3Ch]                ; e_lfanew
    lea rdi, [r12 + rax]                ; PE header
    
    ; Get export directory RVA
    mov eax, [rdi + 88h]                ; OptionalHeader.DataDirectory[0].VirtualAddress
    test eax, eax
    jz not_found
    
    lea rsi, [r12 + rax]                ; Export directory
    
    ; Get export tables
    mov eax, [rsi + 20h]                ; AddressOfNames
    lea rbx, [r12 + rax]                ; Names table
    
    mov ecx, [rsi + 18h]                ; NumberOfNames
    xor edi, edi                        ; Index
    
search_loop:
    cmp edi, ecx
    jge not_found
    
    ; Get name RVA and address
    mov eax, [rbx + rdi*4]
    lea rdx, [r12 + rax]                ; Name string
    
    ; Hash the name
    call HashString
    cmp eax, r13d
    je found
    
    inc edi
    jmp search_loop
    
found:
    ; Get ordinal
    mov eax, [rsi + 24h]                ; AddressOfNameOrdinals
    lea rax, [r12 + rax]
    movzx eax, WORD PTR [rax + rdi*2]
    
    ; Get function address
    mov ecx, [rsi + 1Ch]                ; AddressOfFunctions
    lea rcx, [r12 + rcx]
    mov eax, [rcx + rax*4]
    lea rax, [r12 + rax]
    jmp done
    
not_found:
    xor eax, eax
    
done:
    add rsp, 56
    pop r13
    pop r12
    pop rsi
    pop rdi
    pop rbx
    ret
FindExportByHash ENDP

;-----------------------------------------------------------------------------
; HashString - Compute djb2 hash of string
;-----------------------------------------------------------------------------
; Parameters: RDX = String pointer
; Returns: EAX = Hash
;-----------------------------------------------------------------------------
HashString PROC
    push rbx
    
    mov eax, 5381                       ; djb2 seed
    
hash_loop:
    movzx ecx, BYTE PTR [rdx]
    test cl, cl
    jz done
    
    ; hash = hash * 33 + c
    mov ebx, eax
    shl eax, 5
    add eax, ebx
    add eax, ecx
    
    inc rdx
    jmp hash_loop
    
done:
    pop rbx
    ret
HashString ENDP

END

